// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f https://github.com/strimzi/strimzi-kafka-operator/releases/download/0.40.0/strimzi-crds-0.40.0.yaml

package v1beta2

import "strings"

#Kafka: {
	// APIVersion defines the versioned schema of this representation
	// of an object. Servers should convert recognized schemas to the
	// latest internal value, and may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "kafka.strimzi.io/v1beta2"

	// Kind is a string value representing the REST resource this
	// object represents. Servers may infer this from the endpoint
	// the client submits requests to. Cannot be updated. In
	// CamelCase. More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "Kafka"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// The specification of the Kafka and ZooKeeper clusters, and
	// Topic Operator.
	spec!: #KafkaSpec
}

// The specification of the Kafka and ZooKeeper clusters, and
// Topic Operator.
#KafkaSpec: {
	// Configuration of the clients certificate authority.
	clientsCa?: {
		// How should CA certificate expiration be handled when
		// `generateCertificateAuthority=true`. The default is for a new
		// CA certificate to be generated reusing the existing private
		// key.
		certificateExpirationPolicy?: "renew-certificate" | "replace-key"

		// If true then Certificate Authority certificates will be
		// generated automatically. Otherwise the user will need to
		// provide a Secret with the CA certificate. Default is true.
		generateCertificateAuthority?: bool

		// If `true`, the Cluster and Client CA Secrets are configured
		// with the `ownerReference` set to the `Kafka` resource. If the
		// `Kafka` resource is deleted when `true`, the CA Secrets are
		// also deleted. If `false`, the `ownerReference` is disabled. If
		// the `Kafka` resource is deleted when `false`, the CA Secrets
		// are retained and available for reuse. Default is `true`.
		generateSecretOwnerReference?: bool

		// The number of days in the certificate renewal period. This is
		// the number of days before the a certificate expires during
		// which renewal actions may be performed. When
		// `generateCertificateAuthority` is true, this will cause the
		// generation of a new certificate. When
		// `generateCertificateAuthority` is true, this will cause extra
		// logging at WARN level about the pending certificate expiry.
		// Default is 30.
		renewalDays?: >=1 & int

		// The number of days generated certificates should be valid for.
		// The default is 365.
		validityDays?: >=1 & int
	}

	// Configuration of the cluster certificate authority.
	clusterCa?: {
		// How should CA certificate expiration be handled when
		// `generateCertificateAuthority=true`. The default is for a new
		// CA certificate to be generated reusing the existing private
		// key.
		certificateExpirationPolicy?: "renew-certificate" | "replace-key"

		// If true then Certificate Authority certificates will be
		// generated automatically. Otherwise the user will need to
		// provide a Secret with the CA certificate. Default is true.
		generateCertificateAuthority?: bool

		// If `true`, the Cluster and Client CA Secrets are configured
		// with the `ownerReference` set to the `Kafka` resource. If the
		// `Kafka` resource is deleted when `true`, the CA Secrets are
		// also deleted. If `false`, the `ownerReference` is disabled. If
		// the `Kafka` resource is deleted when `false`, the CA Secrets
		// are retained and available for reuse. Default is `true`.
		generateSecretOwnerReference?: bool

		// The number of days in the certificate renewal period. This is
		// the number of days before the a certificate expires during
		// which renewal actions may be performed. When
		// `generateCertificateAuthority` is true, this will cause the
		// generation of a new certificate. When
		// `generateCertificateAuthority` is true, this will cause extra
		// logging at WARN level about the pending certificate expiry.
		// Default is 30.
		renewalDays?: >=1 & int

		// The number of days generated certificates should be valid for.
		// The default is 365.
		validityDays?: >=1 & int
	}

	// Configuration for Cruise Control deployment. Deploys a Cruise
	// Control instance when specified.
	cruiseControl?: {
		// The Cruise Control `brokerCapacity` configuration.
		brokerCapacity?: {
			// Broker capacity for CPU resource in cores or millicores. For
			// example, 1, 1.500, 1500m. For more information on valid CPU
			// resource units see
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.
			cpu?: =~"^[0-9]+([.][0-9]{0,3}|[m]?)$"

			// Broker capacity for CPU resource utilization as a percentage (0
			// - 100).
			cpuUtilization?: uint & <=100

			// Broker capacity for disk in bytes. Use a number value with
			// either standard Kubernetes byte units (K, M, G, or T), their
			// bibyte (power of two) equivalents (Ki, Mi, Gi, or Ti), or a
			// byte value with or without E notation. For example, 100000M,
			// 100000Mi, 104857600000, or 1e+11.
			disk?: =~"^[0-9]+([.][0-9]*)?([KMGTPE]i?|e[0-9]+)?$"

			// Broker capacity for inbound network throughput in bytes per
			// second. Use an integer value with standard Kubernetes byte
			// units (K, M, G) or their bibyte (power of two) equivalents
			// (Ki, Mi, Gi) per second. For example, 10000KiB/s.
			inboundNetwork?: =~"^[0-9]+([KMG]i?)?B/s$"

			// Broker capacity for outbound network throughput in bytes per
			// second. Use an integer value with standard Kubernetes byte
			// units (K, M, G) or their bibyte (power of two) equivalents
			// (Ki, Mi, Gi) per second. For example, 10000KiB/s.
			outboundNetwork?: =~"^[0-9]+([KMG]i?)?B/s$"

			// Overrides for individual brokers. The `overrides` property lets
			// you specify a different capacity configuration for different
			// brokers.
			overrides?: [...{
				// List of Kafka brokers (broker identifiers).
				brokers: [...int]

				// Broker capacity for CPU resource in cores or millicores. For
				// example, 1, 1.500, 1500m. For more information on valid CPU
				// resource units see
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.
				cpu?: =~"^[0-9]+([.][0-9]{0,3}|[m]?)$"

				// Broker capacity for inbound network throughput in bytes per
				// second. Use an integer value with standard Kubernetes byte
				// units (K, M, G) or their bibyte (power of two) equivalents
				// (Ki, Mi, Gi) per second. For example, 10000KiB/s.
				inboundNetwork?: =~"^[0-9]+([KMG]i?)?B/s$"

				// Broker capacity for outbound network throughput in bytes per
				// second. Use an integer value with standard Kubernetes byte
				// units (K, M, G) or their bibyte (power of two) equivalents
				// (Ki, Mi, Gi) per second. For example, 10000KiB/s.
				outboundNetwork?: =~"^[0-9]+([KMG]i?)?B/s$"
			}]
		}

		// The Cruise Control configuration. For a full list of
		// configuration options refer to
		// https://github.com/linkedin/cruise-control/wiki/Configurations.
		// Note that properties with the following prefixes cannot be
		// set: bootstrap.servers, client.id, zookeeper., network.,
		// security., failed.brokers.zk.path,webserver.http.,
		// webserver.api.urlprefix, webserver.session.path,
		// webserver.accesslog., two.step.,
		// request.reason.required,metric.reporter.sampler.bootstrap.servers,
		// capacity.config.file, self.healing., ssl.,
		// kafka.broker.failure.detection.enable,
		// topic.config.provider.class (with the exception of:
		// ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,
		// webserver.http.cors.enabled, webserver.http.cors.origin,
		// webserver.http.cors.exposeheaders, webserver.security.enable,
		// webserver.ssl.enable).
		config?: {
			...
		}

		// The container image used for Cruise Control pods. If no image
		// name is explicitly specified, the image name corresponds to
		// the name specified in the Cluster Operator configuration. If
		// an image name is not defined in the Cluster Operator
		// configuration, a default value is used.
		image?: string

		// JVM Options for the Cruise Control container.
		jvmOptions?: {
			// A map of -XX options to the JVM.
			"-XX"?: {
				[string]: string
			}

			// -Xms option to to the JVM.
			"-Xms"?: =~"^[0-9]+[mMgG]?$"

			// -Xmx option to to the JVM.
			"-Xmx"?: =~"^[0-9]+[mMgG]?$"

			// Specifies whether the Garbage Collection logging is enabled.
			// The default is false.
			gcLoggingEnabled?: bool

			// A map of additional system properties which will be passed
			// using the `-D` option to the JVM.
			javaSystemProperties?: [...{
				// The system property name.
				name?: string

				// The system property value.
				value?: string
			}]
		}

		// Pod liveness checking for the Cruise Control container.
		livenessProbe?: {
			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: >=1 & int

			// The initial delay before first the health is first checked.
			// Default to 15 seconds. Minimum value is 0.
			initialDelaySeconds?: >=0 & int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: >=1 & int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness. Minimum value is 1.
			successThreshold?: >=1 & int

			// The timeout for each attempted health check. Default to 5
			// seconds. Minimum value is 1.
			timeoutSeconds?: >=1 & int
		}

		// Logging configuration (Log4j 2) for Cruise Control.
		logging?: {
			// A Map from logger name to logger level.
			loggers?: {
				[string]: string
			}

			// Logging type, must be either 'inline' or 'external'.
			type: "inline" | "external"
			valueFrom?: {
				// Reference to the key in the ConfigMap containing the
				// configuration.
				configMapKeyRef?: {
					key?:      string
					name?:     string
					optional?: bool
				}
			}
		}

		// Metrics configuration.
		metricsConfig?: {
			// Metrics type. Only 'jmxPrometheusExporter' supported currently.
			type: "jmxPrometheusExporter"
			valueFrom: {
				// Reference to the key in the ConfigMap containing the
				// configuration.
				configMapKeyRef?: {
					key?:      string
					name?:     string
					optional?: bool
				}
			}
		}

		// Pod readiness checking for the Cruise Control container.
		readinessProbe?: {
			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: >=1 & int

			// The initial delay before first the health is first checked.
			// Default to 15 seconds. Minimum value is 0.
			initialDelaySeconds?: >=0 & int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: >=1 & int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness. Minimum value is 1.
			successThreshold?: >=1 & int

			// The timeout for each attempted health check. Default to 5
			// seconds. Minimum value is 1.
			timeoutSeconds?: >=1 & int
		}

		// CPU and memory resources to reserve for the Cruise Control
		// container.
		resources?: {
			claims?: [...{
				name?: string
			}]
			limits?: {
				...
			}
			requests?: {
				...
			}
		}

		// Template to specify how Cruise Control resources, `Deployments`
		// and `Pods`, are generated.
		template?: {
			// Template for Cruise Control API `Service`.
			apiService?: {
				// Specifies the IP Families used by the service. Available
				// options are `IPv4` and `IPv6`. If unspecified, Kubernetes will
				// choose the default value based on the `ipFamilyPolicy`
				// setting.
				ipFamilies?: [..."IPv4" | "IPv6"]

				// Specifies the IP Family Policy used by the service. Available
				// options are `SingleStack`, `PreferDualStack` and
				// `RequireDualStack`. `SingleStack` is for a single IP family.
				// `PreferDualStack` is for two IP families on dual-stack
				// configured clusters or a single IP family on single-stack
				// clusters. `RequireDualStack` fails unless there are two IP
				// families on dual-stack configured clusters. If unspecified,
				// Kubernetes will choose the default value based on the service
				// type.
				ipFamilyPolicy?: "SingleStack" | "PreferDualStack" | "RequireDualStack"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for the Cruise Control container.
			cruiseControlContainer?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}

			// Template for Cruise Control `Deployment`.
			deployment?: {
				// Pod replacement strategy for deployment configuration changes.
				// Valid values are `RollingUpdate` and `Recreate`. Defaults to
				// `RollingUpdate`.
				deploymentStrategy?: "RollingUpdate" | "Recreate"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for Cruise Control `Pods`.
			pod?: {
				// The pod's affinity rules.
				affinity?: {
					nodeAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							preference?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							nodeSelectorTerms?: [...{
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}]
						}
					}
					podAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
					podAntiAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
				}

				// Indicates whether information about services should be injected
				// into Pod's environment variables.
				enableServiceLinks?: bool

				// The pod's HostAliases. HostAliases is an optional list of hosts
				// and IPs that will be injected into the Pod's hosts file if
				// specified.
				hostAliases?: [...{
					hostnames?: [...string]
					ip?: string
				}]

				// List of references to secrets in the same namespace to use for
				// pulling any of the images used by this Pod. When the
				// `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster
				// Operator and the `imagePullSecrets` option are specified, only
				// the `imagePullSecrets` variable is used and the
				// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
				imagePullSecrets?: [...{
					name?: string
				}]

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}

				// The name of the priority class used to assign priority to the
				// pods.
				priorityClassName?: string

				// The name of the scheduler used to dispatch this `Pod`. If not
				// specified, the default scheduler will be used.
				schedulerName?: string

				// Configures pod-level security attributes and common container
				// settings.
				securityContext?: {
					fsGroup?:             int
					fsGroupChangePolicy?: string
					runAsGroup?:          int
					runAsNonRoot?:        bool
					runAsUser?:           int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					supplementalGroups?: [...int]
					sysctls?: [...{
						name?:  string
						value?: string
					}]
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}

				// The grace period is the duration in seconds after the processes
				// running in the pod are sent a termination signal, and the time
				// when the processes are forcibly halted with a kill signal. Set
				// this value to longer than the expected cleanup time for your
				// process. Value must be a non-negative integer. A zero value
				// indicates delete immediately. You might need to increase the
				// grace period for very large Kafka clusters, so that the Kafka
				// brokers have enough time to transfer their work to another
				// broker before they are terminated. Defaults to 30 seconds.
				terminationGracePeriodSeconds?: >=0 & int

				// Defines the total amount (for example `1Gi`) of local storage
				// required for temporary EmptyDir volume (`/tmp`). Default value
				// is `5Mi`.
				tmpDirSizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

				// The pod's tolerations.
				tolerations?: [...{
					effect?:            string
					key?:               string
					operator?:          string
					tolerationSeconds?: int
					value?:             string
				}]

				// The pod's topology spread constraints.
				topologySpreadConstraints?: [...{
					labelSelector?: {
						matchExpressions?: [...{
							key?:      string
							operator?: string
							values?: [...string]
						}]
						matchLabels?: {
							[string]: string
						}
					}
					matchLabelKeys?: [...string]
					maxSkew?:            int
					minDomains?:         int
					nodeAffinityPolicy?: string
					nodeTaintsPolicy?:   string
					topologyKey?:        string
					whenUnsatisfiable?:  string
				}]
			}

			// Template for Cruise Control `PodDisruptionBudget`.
			podDisruptionBudget?: {
				// Maximum number of unavailable pods to allow automatic Pod
				// eviction. A Pod eviction is allowed when the `maxUnavailable`
				// number of pods or fewer are unavailable after the eviction.
				// Setting this value to 0 prevents all voluntary evictions, so
				// the pods must be evicted manually. Defaults to 1.
				maxUnavailable?: >=0 & int

				// Metadata to apply to the `PodDisruptionBudgetTemplate`
				// resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			serviceAccount?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for the Cruise Control TLS sidecar container.
			tlsSidecarContainer?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}
		}

		// TLS sidecar configuration.
		tlsSidecar?: {
			// The docker image for the container.
			image?: string

			// Pod liveness checking.
			livenessProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// The log level for the TLS sidecar. Default value is `notice`.
			logLevel?: "emerg" | "alert" | "crit" | "err" | "warning" | "notice" | "info" | "debug"

			// Pod readiness checking.
			readinessProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// CPU and memory resources to reserve.
			resources?: {
				claims?: [...{
					name?: string
				}]
				limits?: {
					...
				}
				requests?: {
					...
				}
			}
		}
	}

	// Configuration of the Entity Operator.
	entityOperator?: {
		// Template for Entity Operator resources. The template allows
		// users to specify how a `Deployment` and `Pod` is generated.
		template?: {
			// Template for Entity Operator `Deployment`.
			deployment?: {
				// Pod replacement strategy for deployment configuration changes.
				// Valid values are `RollingUpdate` and `Recreate`. Defaults to
				// `RollingUpdate`.
				deploymentStrategy?: "RollingUpdate" | "Recreate"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			entityOperatorRole?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for Entity Operator `Pods`.
			pod?: {
				// The pod's affinity rules.
				affinity?: {
					nodeAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							preference?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							nodeSelectorTerms?: [...{
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}]
						}
					}
					podAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
					podAntiAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
				}

				// Indicates whether information about services should be injected
				// into Pod's environment variables.
				enableServiceLinks?: bool

				// The pod's HostAliases. HostAliases is an optional list of hosts
				// and IPs that will be injected into the Pod's hosts file if
				// specified.
				hostAliases?: [...{
					hostnames?: [...string]
					ip?: string
				}]

				// List of references to secrets in the same namespace to use for
				// pulling any of the images used by this Pod. When the
				// `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster
				// Operator and the `imagePullSecrets` option are specified, only
				// the `imagePullSecrets` variable is used and the
				// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
				imagePullSecrets?: [...{
					name?: string
				}]

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}

				// The name of the priority class used to assign priority to the
				// pods.
				priorityClassName?: string

				// The name of the scheduler used to dispatch this `Pod`. If not
				// specified, the default scheduler will be used.
				schedulerName?: string

				// Configures pod-level security attributes and common container
				// settings.
				securityContext?: {
					fsGroup?:             int
					fsGroupChangePolicy?: string
					runAsGroup?:          int
					runAsNonRoot?:        bool
					runAsUser?:           int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					supplementalGroups?: [...int]
					sysctls?: [...{
						name?:  string
						value?: string
					}]
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}

				// The grace period is the duration in seconds after the processes
				// running in the pod are sent a termination signal, and the time
				// when the processes are forcibly halted with a kill signal. Set
				// this value to longer than the expected cleanup time for your
				// process. Value must be a non-negative integer. A zero value
				// indicates delete immediately. You might need to increase the
				// grace period for very large Kafka clusters, so that the Kafka
				// brokers have enough time to transfer their work to another
				// broker before they are terminated. Defaults to 30 seconds.
				terminationGracePeriodSeconds?: >=0 & int

				// Defines the total amount (for example `1Gi`) of local storage
				// required for temporary EmptyDir volume (`/tmp`). Default value
				// is `5Mi`.
				tmpDirSizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

				// The pod's tolerations.
				tolerations?: [...{
					effect?:            string
					key?:               string
					operator?:          string
					tolerationSeconds?: int
					value?:             string
				}]

				// The pod's topology spread constraints.
				topologySpreadConstraints?: [...{
					labelSelector?: {
						matchExpressions?: [...{
							key?:      string
							operator?: string
							values?: [...string]
						}]
						matchLabels?: {
							[string]: string
						}
					}
					matchLabelKeys?: [...string]
					maxSkew?:            int
					minDomains?:         int
					nodeAffinityPolicy?: string
					nodeTaintsPolicy?:   string
					topologyKey?:        string
					whenUnsatisfiable?:  string
				}]
			}
			serviceAccount?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for the Entity Operator TLS sidecar container.
			tlsSidecarContainer?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}

			// Template for the Entity Topic Operator container.
			topicOperatorContainer?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}
			topicOperatorRoleBinding?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for the Entity User Operator container.
			userOperatorContainer?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}
			userOperatorRoleBinding?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
		}

		// TLS sidecar configuration.
		tlsSidecar?: {
			// The docker image for the container.
			image?: string

			// Pod liveness checking.
			livenessProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// The log level for the TLS sidecar. Default value is `notice`.
			logLevel?: "emerg" | "alert" | "crit" | "err" | "warning" | "notice" | "info" | "debug"

			// Pod readiness checking.
			readinessProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// CPU and memory resources to reserve.
			resources?: {
				claims?: [...{
					name?: string
				}]
				limits?: {
					...
				}
				requests?: {
					...
				}
			}
		}

		// Configuration of the Topic Operator.
		topicOperator?: {
			// The image to use for the Topic Operator.
			image?: string

			// JVM Options for pods.
			jvmOptions?: {
				// A map of -XX options to the JVM.
				"-XX"?: {
					[string]: string
				}

				// -Xms option to to the JVM.
				"-Xms"?: =~"^[0-9]+[mMgG]?$"

				// -Xmx option to to the JVM.
				"-Xmx"?: =~"^[0-9]+[mMgG]?$"

				// Specifies whether the Garbage Collection logging is enabled.
				// The default is false.
				gcLoggingEnabled?: bool

				// A map of additional system properties which will be passed
				// using the `-D` option to the JVM.
				javaSystemProperties?: [...{
					// The system property name.
					name?: string

					// The system property value.
					value?: string
				}]
			}

			// Pod liveness checking.
			livenessProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// Logging configuration.
			logging?: {
				// A Map from logger name to logger level.
				loggers?: {
					[string]: string
				}

				// Logging type, must be either 'inline' or 'external'.
				type: "inline" | "external"
				valueFrom?: {
					// Reference to the key in the ConfigMap containing the
					// configuration.
					configMapKeyRef?: {
						key?:      string
						name?:     string
						optional?: bool
					}
				}
			}

			// Pod readiness checking.
			readinessProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// Interval between periodic reconciliations.
			reconciliationIntervalSeconds?: >=0 & int

			// CPU and memory resources to reserve.
			resources?: {
				claims?: [...{
					name?: string
				}]
				limits?: {
					...
				}
				requests?: {
					...
				}
			}

			// Pod startup checking.
			startupProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// The number of attempts at getting topic metadata.
			topicMetadataMaxAttempts?: >=0 & int

			// The namespace the Topic Operator should watch.
			watchedNamespace?: string

			// Timeout for the ZooKeeper session.
			zookeeperSessionTimeoutSeconds?: >=0 & int
		}

		// Configuration of the User Operator.
		userOperator?: {
			// The image to use for the User Operator.
			image?: string

			// JVM Options for pods.
			jvmOptions?: {
				// A map of -XX options to the JVM.
				"-XX"?: {
					[string]: string
				}

				// -Xms option to to the JVM.
				"-Xms"?: =~"^[0-9]+[mMgG]?$"

				// -Xmx option to to the JVM.
				"-Xmx"?: =~"^[0-9]+[mMgG]?$"

				// Specifies whether the Garbage Collection logging is enabled.
				// The default is false.
				gcLoggingEnabled?: bool

				// A map of additional system properties which will be passed
				// using the `-D` option to the JVM.
				javaSystemProperties?: [...{
					// The system property name.
					name?: string

					// The system property value.
					value?: string
				}]
			}

			// Pod liveness checking.
			livenessProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// Logging configuration.
			logging?: {
				// A Map from logger name to logger level.
				loggers?: {
					[string]: string
				}

				// Logging type, must be either 'inline' or 'external'.
				type: "inline" | "external"
				valueFrom?: {
					// Reference to the key in the ConfigMap containing the
					// configuration.
					configMapKeyRef?: {
						key?:      string
						name?:     string
						optional?: bool
					}
				}
			}

			// Pod readiness checking.
			readinessProbe?: {
				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: >=1 & int

				// The initial delay before first the health is first checked.
				// Default to 15 seconds. Minimum value is 0.
				initialDelaySeconds?: >=0 & int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: >=1 & int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness. Minimum value is 1.
				successThreshold?: >=1 & int

				// The timeout for each attempted health check. Default to 5
				// seconds. Minimum value is 1.
				timeoutSeconds?: >=1 & int
			}

			// Interval between periodic reconciliations.
			reconciliationIntervalSeconds?: >=0 & int

			// CPU and memory resources to reserve.
			resources?: {
				claims?: [...{
					name?: string
				}]
				limits?: {
					...
				}
				requests?: {
					...
				}
			}

			// The prefix that will be added to the KafkaUser name to be used
			// as the Secret name.
			secretPrefix?: string

			// The namespace the User Operator should watch.
			watchedNamespace?: string

			// Timeout for the ZooKeeper session.
			zookeeperSessionTimeoutSeconds?: >=0 & int
		}
	}

	// As of Strimzi 0.35.0, JMXTrans is not supported anymore and
	// this option is ignored.
	jmxTrans?: {
		// The image to use for the JmxTrans.
		image?: string

		// Queries to send to the Kafka brokers to define what data should
		// be read from each broker. For more information on these
		// properties see,
		// xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate`
		// schema reference].
		kafkaQueries: [...{
			// Determine which attributes of the targeted MBean should be
			// included.
			attributes: [...string]

			// List of the names of output definitions specified in the
			// spec.kafka.jmxTrans.outputDefinitions that have defined where
			// JMX metrics are pushed to, and in which data format.
			outputs: [...string]

			// If using wildcards instead of a specific MBean then the data is
			// gathered from multiple MBeans. Otherwise if specifying an
			// MBean then data is gathered from that specified MBean.
			targetMBean: string
		}]

		// Sets the logging level of the JmxTrans deployment.For more
		// information see,
		// https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans
		// Logging Level].
		logLevel?: string

		// Defines the output hosts that will be referenced later on. For
		// more information on these properties see,
		// xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate`
		// schema reference].
		outputDefinitions: [...{
			// How many seconds the JmxTrans waits before pushing a new set of
			// data out.
			flushDelayInSeconds?: int

			// The DNS/hostname of the remote host that the data is pushed to.
			host?: string

			// Template for setting the name of the output definition. This is
			// used to identify where to send the results of queries should
			// be sent.
			name: string

			// Template for setting the format of the data that will be
			// pushed.For more information see
			// https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans
			// OutputWriters].
			outputType: string

			// The port of the remote host that the data is pushed to.
			port?: int

			// Template for filtering data to be included in response to a
			// wildcard query. For more information see
			// https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans
			// queries].
			typeNames?: [...string]
		}]

		// CPU and memory resources to reserve.
		resources?: {
			claims?: [...{
				name?: string
			}]
			limits?: {
				...
			}
			requests?: {
				...
			}
		}

		// Template for JmxTrans resources.
		template?: {
			// Template for JmxTrans container.
			container?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}

			// Template for JmxTrans `Deployment`.
			deployment?: {
				// Pod replacement strategy for deployment configuration changes.
				// Valid values are `RollingUpdate` and `Recreate`. Defaults to
				// `RollingUpdate`.
				deploymentStrategy?: "RollingUpdate" | "Recreate"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for JmxTrans `Pods`.
			pod?: {
				// The pod's affinity rules.
				affinity?: {
					nodeAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							preference?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							nodeSelectorTerms?: [...{
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}]
						}
					}
					podAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
					podAntiAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
				}

				// Indicates whether information about services should be injected
				// into Pod's environment variables.
				enableServiceLinks?: bool

				// The pod's HostAliases. HostAliases is an optional list of hosts
				// and IPs that will be injected into the Pod's hosts file if
				// specified.
				hostAliases?: [...{
					hostnames?: [...string]
					ip?: string
				}]

				// List of references to secrets in the same namespace to use for
				// pulling any of the images used by this Pod. When the
				// `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster
				// Operator and the `imagePullSecrets` option are specified, only
				// the `imagePullSecrets` variable is used and the
				// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
				imagePullSecrets?: [...{
					name?: string
				}]

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}

				// The name of the priority class used to assign priority to the
				// pods.
				priorityClassName?: string

				// The name of the scheduler used to dispatch this `Pod`. If not
				// specified, the default scheduler will be used.
				schedulerName?: string

				// Configures pod-level security attributes and common container
				// settings.
				securityContext?: {
					fsGroup?:             int
					fsGroupChangePolicy?: string
					runAsGroup?:          int
					runAsNonRoot?:        bool
					runAsUser?:           int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					supplementalGroups?: [...int]
					sysctls?: [...{
						name?:  string
						value?: string
					}]
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}

				// The grace period is the duration in seconds after the processes
				// running in the pod are sent a termination signal, and the time
				// when the processes are forcibly halted with a kill signal. Set
				// this value to longer than the expected cleanup time for your
				// process. Value must be a non-negative integer. A zero value
				// indicates delete immediately. You might need to increase the
				// grace period for very large Kafka clusters, so that the Kafka
				// brokers have enough time to transfer their work to another
				// broker before they are terminated. Defaults to 30 seconds.
				terminationGracePeriodSeconds?: >=0 & int

				// Defines the total amount (for example `1Gi`) of local storage
				// required for temporary EmptyDir volume (`/tmp`). Default value
				// is `5Mi`.
				tmpDirSizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

				// The pod's tolerations.
				tolerations?: [...{
					effect?:            string
					key?:               string
					operator?:          string
					tolerationSeconds?: int
					value?:             string
				}]

				// The pod's topology spread constraints.
				topologySpreadConstraints?: [...{
					labelSelector?: {
						matchExpressions?: [...{
							key?:      string
							operator?: string
							values?: [...string]
						}]
						matchLabels?: {
							[string]: string
						}
					}
					matchLabelKeys?: [...string]
					maxSkew?:            int
					minDomains?:         int
					nodeAffinityPolicy?: string
					nodeTaintsPolicy?:   string
					topologyKey?:        string
					whenUnsatisfiable?:  string
				}]
			}
			serviceAccount?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
		}
	}

	// Configuration of the Kafka cluster.
	kafka: {
		// Authorization configuration for Kafka brokers.
		authorization?: {
			// Defines whether a Kafka client should be allowed or denied by
			// default when the authorizer fails to query the Open Policy
			// Agent, for example, when it is temporarily unavailable).
			// Defaults to `false` - all actions will be denied.
			allowOnError?: bool

			// Authorization implementation class, which must be available in
			// classpath.
			authorizerClass?: string

			// OAuth Client ID which the Kafka client can use to authenticate
			// against the OAuth server and use the token endpoint URI.
			clientId?: string

			// The connect timeout in seconds when connecting to authorization
			// server. If not set, the effective connect timeout is 60
			// seconds.
			connectTimeoutSeconds?: >=1 & int

			// Whether authorization decision should be delegated to the
			// 'Simple' authorizer if DENIED by Keycloak Authorization
			// Services policies. Default value is `false`.
			delegateToKafkaAcls?: bool

			// Enable or disable TLS hostname verification. Default value is
			// `false`.
			disableTlsHostnameVerification?: bool

			// Enable or disable OAuth metrics. The default value is `false`.
			enableMetrics?: bool

			// The expiration of the records kept in the local cache to avoid
			// querying the Open Policy Agent for every request. Defines how
			// often the cached authorization decisions are reloaded from the
			// Open Policy Agent server. In milliseconds. Defaults to
			// `3600000`.
			expireAfterMs?: int

			// Controls whether the latest grants are fetched for a new
			// session. When enabled, grants are retrieved from Keycloak and
			// cached for the user. The default value is `false`.
			grantsAlwaysLatest?: bool

			// The time, in seconds, between consecutive runs of a job that
			// cleans stale grants from the cache. The default value is 300.
			grantsGcPeriodSeconds?: >=1 & int

			// The time, in seconds, after which an idle grant can be evicted
			// from the cache. The default value is 300.
			grantsMaxIdleTimeSeconds?: >=1 & int

			// The time between two consecutive grants refresh runs in
			// seconds. The default value is 60.
			grantsRefreshPeriodSeconds?: >=0 & int

			// The number of threads to use to refresh grants for active
			// sessions. The more threads, the more parallelism, so the
			// sooner the job completes. However, using more threads places a
			// heavier load on the authorization server. The default value is
			// 5.
			grantsRefreshPoolSize?: >=1 & int

			// The maximum number of retries to attempt if an initial HTTP
			// request fails. If not set, the default is to not attempt any
			// retries.
			httpRetries?: >=0 & int

			// Whether the Accept header should be set in requests to the
			// authorization servers. The default value is `true`.
			includeAcceptHeader?: bool

			// Initial capacity of the local cache used by the authorizer to
			// avoid querying the Open Policy Agent for every request
			// Defaults to `5000`.
			initialCacheCapacity?: int

			// Maximum capacity of the local cache used by the authorizer to
			// avoid querying the Open Policy Agent for every request.
			// Defaults to `50000`.
			maximumCacheSize?: int

			// The read timeout in seconds when connecting to authorization
			// server. If not set, the effective read timeout is 60 seconds.
			readTimeoutSeconds?: >=1 & int

			// List of super users, which are user principals with unlimited
			// access rights.
			superUsers?: [...string]

			// Indicates whether the custom authorizer supports the APIs for
			// managing ACLs using the Kafka Admin API. Defaults to `false`.
			supportsAdminApi?: bool

			// Trusted certificates for TLS connection to the OAuth server.
			tlsTrustedCertificates?: [...{
				// The name of the file certificate in the Secret.
				certificate: string

				// The name of the Secret containing the certificate.
				secretName: string
			}]

			// Authorization server token endpoint URI.
			tokenEndpointUri?: string

			// Authorization type. Currently, the supported types are
			// `simple`, `keycloak`, `opa` and `custom`. `simple`
			// authorization type uses Kafka's built-in authorizer for
			// authorization. `keycloak` authorization type uses Keycloak
			// Authorization Services for authorization. `opa` authorization
			// type uses Open Policy Agent based authorization.`custom`
			// authorization type uses user-provided implementation for
			// authorization.
			type: "simple" | "opa" | "keycloak" | "custom"

			// The URL used to connect to the Open Policy Agent server. The
			// URL has to include the policy which will be queried by the
			// authorizer. This option is required.
			url?: string
		}

		// The image of the init container used for initializing the
		// `broker.rack`.
		brokerRackInitImage?: string

		// Kafka broker config properties with the following prefixes
		// cannot be set: listeners, advertised., broker., listener.,
		// host.name, port, inter.broker.listener.name, sasl., ssl.,
		// security., password., log.dir, zookeeper.connect,
		// zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket,
		// authorizer., super.user, cruise.control.metrics.topic,
		// cruise.control.metrics.reporter.bootstrap.servers, node.id,
		// process.roles, controller., metadata.log.dir,
		// zookeeper.metadata.migration.enable (with the exception of:
		// zookeeper.connection.timeout.ms, sasl.server.max.receive.size,
		// ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,
		// ssl.secure.random.implementation,
		// cruise.control.metrics.topic.num.partitions,
		// cruise.control.metrics.topic.replication.factor,
		// cruise.control.metrics.topic.retention.ms,
		// cruise.control.metrics.topic.auto.create.retries,
		// cruise.control.metrics.topic.auto.create.timeout.ms,
		// cruise.control.metrics.topic.min.insync.replicas,
		// controller.quorum.election.backoff.max.ms,
		// controller.quorum.election.timeout.ms,
		// controller.quorum.fetch.timeout.ms).
		config?: {
			...
		}

		// The container image used for Kafka pods. If the property is not
		// set, the default Kafka image version is determined based on
		// the `version` configuration. The image names are specifically
		// mapped to corresponding versions in the Cluster Operator
		// configuration. Changing the Kafka image version does not
		// automatically update the image versions for other components,
		// such as Kafka Exporter.
		image?: string
		jmxOptions?: {
			authentication?: {
				// Authentication type. Currently the only supported types are
				// `password`.`password` type creates a username and protected
				// port with no TLS.
				type: "password"
			}
		}

		// JVM Options for pods.
		jvmOptions?: {
			// A map of -XX options to the JVM.
			"-XX"?: {
				[string]: string
			}

			// -Xms option to to the JVM.
			"-Xms"?: =~"^[0-9]+[mMgG]?$"

			// -Xmx option to to the JVM.
			"-Xmx"?: =~"^[0-9]+[mMgG]?$"

			// Specifies whether the Garbage Collection logging is enabled.
			// The default is false.
			gcLoggingEnabled?: bool

			// A map of additional system properties which will be passed
			// using the `-D` option to the JVM.
			javaSystemProperties?: [...{
				// The system property name.
				name?: string

				// The system property value.
				value?: string
			}]
		}

		// Configures listeners of Kafka brokers.
		listeners: [...{
			// Authentication configuration for this listener.
			authentication?: {
				// Configure whether the access token is treated as JWT. This must
				// be set to `false` if the authorization server returns opaque
				// tokens. Defaults to `true`.
				accessTokenIsJwt?: bool

				// Configure whether the access token type check is performed or
				// not. This should be set to `false` if the authorization server
				// does not include 'typ' claim in JWT token. Defaults to `true`.
				checkAccessTokenType?: bool

				// Enable or disable audience checking. Audience checks identify
				// the recipients of tokens. If audience checking is enabled, the
				// OAuth Client ID also has to be configured using the `clientId`
				// property. The Kafka broker will reject tokens that do not have
				// its `clientId` in their `aud` (audience) claim.Default value
				// is `false`.
				checkAudience?: bool

				// Enable or disable issuer checking. By default issuer is checked
				// using the value configured by `validIssuerUri`. Default value
				// is `true`.
				checkIssuer?: bool

				// The audience to use when making requests to the authorization
				// server's token endpoint. Used for inter-broker authentication
				// and for configuring OAuth 2.0 over PLAIN using the `clientId`
				// and `secret` method.
				clientAudience?: string

				// OAuth Client ID which the Kafka broker can use to authenticate
				// against the authorization server and use the introspect
				// endpoint URI.
				clientId?: string

				// The scope to use when making requests to the authorization
				// server's token endpoint. Used for inter-broker authentication
				// and for configuring OAuth 2.0 over PLAIN using the `clientId`
				// and `secret` method.
				clientScope?: string

				// Link to Kubernetes Secret containing the OAuth client secret
				// which the Kafka broker can use to authenticate against the
				// authorization server and use the introspect endpoint URI.
				clientSecret?: {
					// The key under which the secret value is stored in the
					// Kubernetes Secret.
					key: string

					// The name of the Kubernetes Secret containing the secret value.
					secretName: string
				}

				// The connect timeout in seconds when connecting to authorization
				// server. If not set, the effective connect timeout is 60
				// seconds.
				connectTimeoutSeconds?: int

				// JsonPath filter query to be applied to the JWT token or to the
				// response of the introspection endpoint for additional token
				// validation. Not set by default.
				customClaimCheck?: string

				// Enable or disable TLS hostname verification. Default value is
				// `false`.
				disableTlsHostnameVerification?: bool

				// Enable or disable ECDSA support by installing BouncyCastle
				// crypto provider. ECDSA support is always enabled. The
				// BouncyCastle libraries are no longer packaged with Strimzi.
				// Value is ignored.
				enableECDSA?: bool

				// Enable or disable OAuth metrics. Default value is `false`.
				enableMetrics?: bool

				// Enable or disable OAuth authentication over SASL_OAUTHBEARER.
				// Default value is `true`.
				enableOauthBearer?: bool

				// Enable or disable OAuth authentication over SASL_PLAIN. There
				// is no re-authentication support when this mechanism is used.
				// Default value is `false`.
				enablePlain?: bool

				// Enable or disable termination of Kafka broker processes due to
				// potentially recoverable runtime errors during startup. Default
				// value is `true`.
				failFast?: bool

				// The fallback username claim to be used for the user id if the
				// claim specified by `userNameClaim` is not present. This is
				// useful when `client_credentials` authentication only results
				// in the client id being provided in another claim. It only
				// takes effect if `userNameClaim` is set.
				fallbackUserNameClaim?: string

				// The prefix to use with the value of `fallbackUserNameClaim` to
				// construct the user id. This only takes effect if
				// `fallbackUserNameClaim` is true, and the value is present for
				// the claim. Mapping usernames and client ids into the same user
				// id space is useful in preventing name collisions.
				fallbackUserNamePrefix?: string

				// JsonPath query used to extract groups for the user during
				// authentication. Extracted groups can be used by a custom
				// authorizer. By default no groups are extracted.
				groupsClaim?: string

				// A delimiter used to parse groups when they are extracted as a
				// single String value rather than a JSON array. Default value is
				// ',' (comma).
				groupsClaimDelimiter?: string

				// The maximum number of retries to attempt if an initial HTTP
				// request fails. If not set, the default is to not attempt any
				// retries.
				httpRetries?: int

				// The pause to take before retrying a failed HTTP request. If not
				// set, the default is to not pause at all but to immediately
				// repeat a request.
				httpRetryPauseMs?: int

				// Whether the Accept header should be set in requests to the
				// authorization servers. The default value is `true`.
				includeAcceptHeader?: bool

				// URI of the token introspection endpoint which can be used to
				// validate opaque non-JWT tokens.
				introspectionEndpointUri?: string

				// URI of the JWKS certificate endpoint, which can be used for
				// local JWT validation.
				jwksEndpointUri?: string

				// Configures how often are the JWKS certificates considered
				// valid. The expiry interval has to be at least 60 seconds
				// longer then the refresh interval specified in
				// `jwksRefreshSeconds`. Defaults to 360 seconds.
				jwksExpirySeconds?: >=1 & int

				// Flag to ignore the 'use' attribute of `key` declarations in a
				// JWKS endpoint response. Default value is `false`.
				jwksIgnoreKeyUse?: bool

				// The minimum pause between two consecutive refreshes. When an
				// unknown signing key is encountered the refresh is scheduled
				// immediately, but will always wait for this minimum pause.
				// Defaults to 1 second.
				jwksMinRefreshPauseSeconds?: >=0 & int

				// Configures how often are the JWKS certificates refreshed. The
				// refresh interval has to be at least 60 seconds shorter then
				// the expiry interval specified in `jwksExpirySeconds`. Defaults
				// to 300 seconds.
				jwksRefreshSeconds?: >=1 & int

				// Configuration to be used for a specific listener. All values
				// are prefixed with listener.name._<listener_name>_.
				listenerConfig?: {}

				// Maximum number of seconds the authenticated session remains
				// valid without re-authentication. This enables Apache Kafka
				// re-authentication feature, and causes sessions to expire when
				// the access token expires. If the access token expires before
				// max time or if max time is reached, the client has to
				// re-authenticate, otherwise the server will drop the
				// connection. Not set by default - the authenticated session
				// does not expire when the access token expires. This option
				// only applies to SASL_OAUTHBEARER authentication mechanism
				// (when `enableOauthBearer` is `true`).
				maxSecondsWithoutReauthentication?: int

				// The read timeout in seconds when connecting to authorization
				// server. If not set, the effective read timeout is 60 seconds.
				readTimeoutSeconds?: int

				// Enable or disable SASL on this listener.
				sasl?: bool

				// Secrets to be mounted to
				// /opt/kafka/custom-authn-secrets/custom-listener-_<listener_name>-<port>_/_<secret_name>_.
				secrets?: [...{
					// The key under which the secret value is stored in the
					// Kubernetes Secret.
					key: string

					// The name of the Kubernetes Secret containing the secret value.
					secretName: string
				}]

				// Trusted certificates for TLS connection to the OAuth server.
				tlsTrustedCertificates?: [...{
					// The name of the file certificate in the Secret.
					certificate: string

					// The name of the Secret containing the certificate.
					secretName: string
				}]

				// URI of the Token Endpoint to use with SASL_PLAIN mechanism when
				// the client authenticates with `clientId` and a `secret`. If
				// set, the client can authenticate over SASL_PLAIN by either
				// setting `username` to `clientId`, and setting `password` to
				// client `secret`, or by setting `username` to account username,
				// and `password` to access token prefixed with `$accessToken:`.
				// If this option is not set, the `password` is always
				// interpreted as an access token (without a prefix), and
				// `username` as the account username (a so called
				// 'no-client-credentials' mode).
				tokenEndpointUri?: string

				// Authentication type. `oauth` type uses SASL OAUTHBEARER
				// Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512
				// Authentication. `tls` type uses TLS Client Authentication.
				// `tls` type is supported only on TLS listeners.`custom` type
				// allows for any authentication type to be used.
				type: "tls" | "scram-sha-512" | "oauth" | "custom"

				// URI of the User Info Endpoint to use as a fallback to obtaining
				// the user id when the Introspection Endpoint does not return
				// information that can be used for the user id.
				userInfoEndpointUri?: string

				// Name of the claim from the JWT authentication token,
				// Introspection Endpoint response or User Info Endpoint response
				// which will be used to extract the user id. Defaults to `sub`.
				userNameClaim?: string

				// URI of the token issuer used for authentication.
				validIssuerUri?: string

				// Valid value for the `token_type` attribute returned by the
				// Introspection Endpoint. No default value, and not checked by
				// default.
				validTokenType?: string
			}

			// Additional listener configuration.
			configuration?: {
				// Bootstrap configuration.
				bootstrap?: {
					// Additional alternative names for the bootstrap service. The
					// alternative names will be added to the list of subject
					// alternative names of the TLS certificates.
					alternativeNames?: [...string]

					// Annotations that will be added to the `Ingress`, `Route`, or
					// `Service` resource. You can use this field to configure DNS
					// providers such as External DNS. This field can be used only
					// with `loadbalancer`, `nodeport`, `route`, or `ingress` type
					// listeners.
					annotations?: {
						[string]: string
					}

					// The bootstrap host. This field will be used in the Ingress
					// resource or in the Route resource to specify the desired
					// hostname. This field can be used only with `route` (optional)
					// or `ingress` (required) type listeners.
					host?: string

					// Labels that will be added to the `Ingress`, `Route`, or
					// `Service` resource. This field can be used only with
					// `loadbalancer`, `nodeport`, `route`, or `ingress` type
					// listeners.
					labels?: {
						[string]: string
					}

					// The loadbalancer is requested with the IP address specified in
					// this field. This feature depends on whether the underlying
					// cloud provider supports specifying the `loadBalancerIP` when a
					// load balancer is created. This field is ignored if the cloud
					// provider does not support the feature.This field can be used
					// only with `loadbalancer` type listener.
					loadBalancerIP?: string

					// Node port for the bootstrap service. This field can be used
					// only with `nodeport` type listener.
					nodePort?: int
				}

				// Reference to the `Secret` which holds the certificate and
				// private key pair which will be used for this listener. The
				// certificate can optionally contain the whole chain. This field
				// can be used only with listeners with enabled TLS encryption.
				brokerCertChainAndKey?: {
					// The name of the file certificate in the Secret.
					certificate: string

					// The name of the private key in the Secret.
					key: string

					// The name of the Secret containing the certificate.
					secretName: string
				}

				// Per-broker configurations.
				brokers?: [...{
					// The host name used in the brokers' `advertised.listeners`.
					advertisedHost?: string

					// The port number used in the brokers' `advertised.listeners`.
					advertisedPort?: int

					// Annotations that will be added to the `Ingress` or `Service`
					// resource. You can use this field to configure DNS providers
					// such as External DNS. This field can be used only with
					// `loadbalancer`, `nodeport`, or `ingress` type listeners.
					annotations?: {
						[string]: string
					}

					// ID of the kafka broker (broker identifier). Broker IDs start
					// from 0 and correspond to the number of broker replicas.
					broker: int

					// The broker host. This field will be used in the Ingress
					// resource or in the Route resource to specify the desired
					// hostname. This field can be used only with `route` (optional)
					// or `ingress` (required) type listeners.
					host?: string

					// Labels that will be added to the `Ingress`, `Route`, or
					// `Service` resource. This field can be used only with
					// `loadbalancer`, `nodeport`, `route`, or `ingress` type
					// listeners.
					labels?: {
						[string]: string
					}

					// The loadbalancer is requested with the IP address specified in
					// this field. This feature depends on whether the underlying
					// cloud provider supports specifying the `loadBalancerIP` when a
					// load balancer is created. This field is ignored if the cloud
					// provider does not support the feature.This field can be used
					// only with `loadbalancer` type listener.
					loadBalancerIP?: string

					// Node port for the per-broker service. This field can be used
					// only with `nodeport` type listener.
					nodePort?: int
				}]

				// Configures a specific class for `Ingress` and `LoadBalancer`
				// that defines which controller will be used. This field can
				// only be used with `ingress` and `loadbalancer` type listeners.
				// If not specified, the default controller is used. For an
				// `ingress` listener, set the `ingressClassName` property in the
				// `Ingress` resources. For a `loadbalancer` listener, set the
				// `loadBalancerClass` property in the `Service` resources.
				class?: string

				// Whether to create the bootstrap service or not. The bootstrap
				// service is created by default (if not specified differently).
				// This field can be used with the `loadBalancer` type listener.
				createBootstrapService?: bool

				// Specifies whether the service routes external traffic to
				// node-local or cluster-wide endpoints. `Cluster` may cause a
				// second hop to another node and obscures the client source IP.
				// `Local` avoids a second hop for LoadBalancer and Nodeport type
				// services and preserves the client source IP (when supported by
				// the infrastructure). If unspecified, Kubernetes will use
				// `Cluster` as the default.This field can be used only with
				// `loadbalancer` or `nodeport` type listener.
				externalTrafficPolicy?: "Local" | "Cluster"

				// A list of finalizers which will be configured for the
				// `LoadBalancer` type Services created for this listener. If
				// supported by the platform, the finalizer
				// `service.kubernetes.io/load-balancer-cleanup` to make sure
				// that the external load balancer is deleted together with the
				// service.For more information, see
				// https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#garbage-collecting-load-balancers.
				// This field can be used only with `loadbalancer` type
				// listeners.
				finalizers?: [...string]

				// Specifies the IP Families used by the service. Available
				// options are `IPv4` and `IPv6`. If unspecified, Kubernetes will
				// choose the default value based on the `ipFamilyPolicy`
				// setting.
				ipFamilies?: [..."IPv4" | "IPv6"]

				// Specifies the IP Family Policy used by the service. Available
				// options are `SingleStack`, `PreferDualStack` and
				// `RequireDualStack`. `SingleStack` is for a single IP family.
				// `PreferDualStack` is for two IP families on dual-stack
				// configured clusters or a single IP family on single-stack
				// clusters. `RequireDualStack` fails unless there are two IP
				// families on dual-stack configured clusters. If unspecified,
				// Kubernetes will choose the default value based on the service
				// type.
				ipFamilyPolicy?: "SingleStack" | "PreferDualStack" | "RequireDualStack"

				// A list of CIDR ranges (for example `10.0.0.0/8` or
				// `130.211.204.1/32`) from which clients can connect to load
				// balancer type listeners. If supported by the platform, traffic
				// through the loadbalancer is restricted to the specified CIDR
				// ranges. This field is applicable only for loadbalancer type
				// services and is ignored if the cloud provider does not support
				// the feature. This field can be used only with `loadbalancer`
				// type listener.
				loadBalancerSourceRanges?: [...string]

				// The maximum connection creation rate we allow in this listener
				// at any time. New connections will be throttled if the limit is
				// reached.
				maxConnectionCreationRate?: int

				// The maximum number of connections we allow for this listener in
				// the broker at any time. New connections are blocked if the
				// limit is reached.
				maxConnections?: int

				// Defines which address type should be used as the node address.
				// Available types are: `ExternalDNS`, `ExternalIP`,
				// `InternalDNS`, `InternalIP` and `Hostname`. By default, the
				// addresses will be used in the following order (the first one
				// found will be used):
				//
				// * `ExternalDNS`
				// * `ExternalIP`
				// * `InternalDNS`
				// * `InternalIP`
				// * `Hostname`
				//
				// This field is used to select the preferred address type, which
				// is checked first. If no address is found for this address
				// type, the other types are checked in the default order. This
				// field can only be used with `nodeport` type listener.
				preferredNodePortAddressType?: "ExternalIP" | "ExternalDNS" | "InternalIP" | "InternalDNS" | "Hostname"

				// Configures whether the Kubernetes service DNS domain should be
				// used or not. If set to `true`, the generated addresses will
				// contain the service DNS domain suffix (by default
				// `.cluster.local`, can be configured using environment variable
				// `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This
				// field can be used only with `internal` and `cluster-ip` type
				// listeners.
				useServiceDnsDomain?: bool
			}

			// Name of the listener. The name will be used to identify the
			// listener and the related Kubernetes objects. The name has to
			// be unique within given a Kafka cluster. The name can consist
			// of lowercase characters and numbers and be up to 11 characters
			// long.
			name: =~"^[a-z0-9]{1,11}$"

			// List of peers which should be able to connect to this listener.
			// Peers in this list are combined using a logical OR operation.
			// If this field is empty or missing, all connections will be
			// allowed for this listener. If this field is present and
			// contains at least one item, the listener only allows the
			// traffic which matches at least one item in this list.
			networkPolicyPeers?: [...{
				ipBlock?: {
					cidr?: string
					except?: [...string]
				}
				namespaceSelector?: {
					matchExpressions?: [...{
						key?:      string
						operator?: string
						values?: [...string]
					}]
					matchLabels?: {
						[string]: string
					}
				}
				podSelector?: {
					matchExpressions?: [...{
						key?:      string
						operator?: string
						values?: [...string]
					}]
					matchLabels?: {
						[string]: string
					}
				}
			}]

			// Port number used by the listener inside Kafka. The port number
			// has to be unique within a given Kafka cluster. Allowed port
			// numbers are 9092 and higher with the exception of ports 9404
			// and 9999, which are already used for Prometheus and JMX.
			// Depending on the listener type, the port number might not be
			// the same as the port number that connects Kafka clients.
			port: >=9092 & int

			// Enables TLS encryption on the listener. This is a required
			// property.
			tls: bool

			// Type of the listener. The supported types are as follows:
			//
			// * `internal` type exposes Kafka internally only within the
			// Kubernetes cluster.
			// * `route` type uses OpenShift Routes to expose Kafka.
			// * `loadbalancer` type uses LoadBalancer type services to expose
			// Kafka.
			// * `nodeport` type uses NodePort type services to expose Kafka.
			// * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka
			// with TLS passthrough.
			// * `cluster-ip` type uses a per-broker `ClusterIP` service.
			type: "internal" | "route" | "loadbalancer" | "nodeport" | "ingress" | "cluster-ip"
		}] & [_, ...]

		// Pod liveness checking.
		livenessProbe?: {
			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: >=1 & int

			// The initial delay before first the health is first checked.
			// Default to 15 seconds. Minimum value is 0.
			initialDelaySeconds?: >=0 & int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: >=1 & int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness. Minimum value is 1.
			successThreshold?: >=1 & int

			// The timeout for each attempted health check. Default to 5
			// seconds. Minimum value is 1.
			timeoutSeconds?: >=1 & int
		}

		// Logging configuration for Kafka.
		logging?: {
			// A Map from logger name to logger level.
			loggers?: {
				[string]: string
			}

			// Logging type, must be either 'inline' or 'external'.
			type: "inline" | "external"
			valueFrom?: {
				// Reference to the key in the ConfigMap containing the
				// configuration.
				configMapKeyRef?: {
					key?:      string
					name?:     string
					optional?: bool
				}
			}
		}

		// The KRaft metadata version used by the Kafka cluster. This
		// property is ignored when running in ZooKeeper mode. If the
		// property is not set, it defaults to the metadata version that
		// corresponds to the `version` property.
		metadataVersion?: string

		// Metrics configuration.
		metricsConfig?: {
			// Metrics type. Only 'jmxPrometheusExporter' supported currently.
			type: "jmxPrometheusExporter"
			valueFrom: {
				// Reference to the key in the ConfigMap containing the
				// configuration.
				configMapKeyRef?: {
					key?:      string
					name?:     string
					optional?: bool
				}
			}
		}
		rack?: {
			// A key that matches labels assigned to the Kubernetes cluster
			// nodes. The value of the label is used to set a broker's
			// `broker.rack` config, and the `client.rack` config for Kafka
			// Connect or MirrorMaker 2.
			topologyKey: string
		}

		// Pod readiness checking.
		readinessProbe?: {
			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: >=1 & int

			// The initial delay before first the health is first checked.
			// Default to 15 seconds. Minimum value is 0.
			initialDelaySeconds?: >=0 & int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: >=1 & int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness. Minimum value is 1.
			successThreshold?: >=1 & int

			// The timeout for each attempted health check. Default to 5
			// seconds. Minimum value is 1.
			timeoutSeconds?: >=1 & int
		}

		// The number of pods in the cluster. This property is required
		// when node pools are not used.
		replicas?: >=1 & int

		// CPU and memory resources to reserve.
		resources?: {
			claims?: [...{
				name?: string
			}]
			limits?: {
				...
			}
			requests?: {
				...
			}
		}

		// Storage configuration (disk). Cannot be updated. This property
		// is required when node pools are not used.
		storage?: {
			// The storage class to use for dynamic volume allocation.
			class?: string

			// Specifies if the persistent volume claim has to be deleted when
			// the cluster is un-deployed.
			deleteClaim?: bool

			// Storage identification number. It is mandatory only for storage
			// volumes defined in a storage of type 'jbod'.
			id?: >=0 & int

			// Overrides for individual brokers. The `overrides` field allows
			// to specify a different configuration for different brokers.
			overrides?: [...{
				// Id of the kafka broker (broker identifier).
				broker?: int

				// The storage class to use for dynamic volume allocation for this
				// broker.
				class?: string
			}]

			// Specifies a specific persistent volume to use. It contains
			// key:value pairs representing labels for selecting such a
			// volume.
			selector?: {
				[string]: string
			}

			// When `type=persistent-claim`, defines the size of the
			// persistent volume claim, such as 100Gi. Mandatory when
			// `type=persistent-claim`.
			size?: string

			// When type=ephemeral, defines the total amount of local storage
			// required for this EmptyDir volume (for example 1Gi).
			sizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

			// Storage type, must be either 'ephemeral', 'persistent-claim',
			// or 'jbod'.
			type: "ephemeral" | "persistent-claim" | "jbod"

			// List of volumes as Storage objects representing the JBOD disks
			// array.
			volumes?: [...{
				// The storage class to use for dynamic volume allocation.
				class?: string

				// Specifies if the persistent volume claim has to be deleted when
				// the cluster is un-deployed.
				deleteClaim?: bool

				// Storage identification number. It is mandatory only for storage
				// volumes defined in a storage of type 'jbod'.
				id?: >=0 & int

				// Overrides for individual brokers. The `overrides` field allows
				// to specify a different configuration for different brokers.
				overrides?: [...{
					// Id of the kafka broker (broker identifier).
					broker?: int

					// The storage class to use for dynamic volume allocation for this
					// broker.
					class?: string
				}]

				// Specifies a specific persistent volume to use. It contains
				// key:value pairs representing labels for selecting such a
				// volume.
				selector?: {
					[string]: string
				}

				// When `type=persistent-claim`, defines the size of the
				// persistent volume claim, such as 100Gi. Mandatory when
				// `type=persistent-claim`.
				size?: string

				// When type=ephemeral, defines the total amount of local storage
				// required for this EmptyDir volume (for example 1Gi).
				sizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

				// Storage type, must be either 'ephemeral' or 'persistent-claim'.
				type: "ephemeral" | "persistent-claim"
			}]
		}

		// Template for Kafka cluster resources. The template allows users
		// to specify how the Kubernetes resources are generated.
		template?: {
			// Template for Kafka bootstrap `Service`.
			bootstrapService?: {
				// Specifies the IP Families used by the service. Available
				// options are `IPv4` and `IPv6`. If unspecified, Kubernetes will
				// choose the default value based on the `ipFamilyPolicy`
				// setting.
				ipFamilies?: [..."IPv4" | "IPv6"]

				// Specifies the IP Family Policy used by the service. Available
				// options are `SingleStack`, `PreferDualStack` and
				// `RequireDualStack`. `SingleStack` is for a single IP family.
				// `PreferDualStack` is for two IP families on dual-stack
				// configured clusters or a single IP family on single-stack
				// clusters. `RequireDualStack` fails unless there are two IP
				// families on dual-stack configured clusters. If unspecified,
				// Kubernetes will choose the default value based on the service
				// type.
				ipFamilyPolicy?: "SingleStack" | "PreferDualStack" | "RequireDualStack"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for Kafka broker `Service`.
			brokersService?: {
				// Specifies the IP Families used by the service. Available
				// options are `IPv4` and `IPv6`. If unspecified, Kubernetes will
				// choose the default value based on the `ipFamilyPolicy`
				// setting.
				ipFamilies?: [..."IPv4" | "IPv6"]

				// Specifies the IP Family Policy used by the service. Available
				// options are `SingleStack`, `PreferDualStack` and
				// `RequireDualStack`. `SingleStack` is for a single IP family.
				// `PreferDualStack` is for two IP families on dual-stack
				// configured clusters or a single IP family on single-stack
				// clusters. `RequireDualStack` fails unless there are two IP
				// families on dual-stack configured clusters. If unspecified,
				// Kubernetes will choose the default value based on the service
				// type.
				ipFamilyPolicy?: "SingleStack" | "PreferDualStack" | "RequireDualStack"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			clusterCaCert?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			clusterRoleBinding?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			externalBootstrapIngress?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			externalBootstrapRoute?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			externalBootstrapService?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for the Kafka init container.
			initContainer?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}
			jmxSecret?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for the Kafka broker container.
			kafkaContainer?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}
			perPodIngress?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			perPodRoute?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			perPodService?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			persistentVolumeClaim?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for Kafka `Pods`.
			pod?: {
				// The pod's affinity rules.
				affinity?: {
					nodeAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							preference?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							nodeSelectorTerms?: [...{
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}]
						}
					}
					podAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
					podAntiAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
				}

				// Indicates whether information about services should be injected
				// into Pod's environment variables.
				enableServiceLinks?: bool

				// The pod's HostAliases. HostAliases is an optional list of hosts
				// and IPs that will be injected into the Pod's hosts file if
				// specified.
				hostAliases?: [...{
					hostnames?: [...string]
					ip?: string
				}]

				// List of references to secrets in the same namespace to use for
				// pulling any of the images used by this Pod. When the
				// `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster
				// Operator and the `imagePullSecrets` option are specified, only
				// the `imagePullSecrets` variable is used and the
				// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
				imagePullSecrets?: [...{
					name?: string
				}]

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}

				// The name of the priority class used to assign priority to the
				// pods.
				priorityClassName?: string

				// The name of the scheduler used to dispatch this `Pod`. If not
				// specified, the default scheduler will be used.
				schedulerName?: string

				// Configures pod-level security attributes and common container
				// settings.
				securityContext?: {
					fsGroup?:             int
					fsGroupChangePolicy?: string
					runAsGroup?:          int
					runAsNonRoot?:        bool
					runAsUser?:           int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					supplementalGroups?: [...int]
					sysctls?: [...{
						name?:  string
						value?: string
					}]
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}

				// The grace period is the duration in seconds after the processes
				// running in the pod are sent a termination signal, and the time
				// when the processes are forcibly halted with a kill signal. Set
				// this value to longer than the expected cleanup time for your
				// process. Value must be a non-negative integer. A zero value
				// indicates delete immediately. You might need to increase the
				// grace period for very large Kafka clusters, so that the Kafka
				// brokers have enough time to transfer their work to another
				// broker before they are terminated. Defaults to 30 seconds.
				terminationGracePeriodSeconds?: >=0 & int

				// Defines the total amount (for example `1Gi`) of local storage
				// required for temporary EmptyDir volume (`/tmp`). Default value
				// is `5Mi`.
				tmpDirSizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

				// The pod's tolerations.
				tolerations?: [...{
					effect?:            string
					key?:               string
					operator?:          string
					tolerationSeconds?: int
					value?:             string
				}]

				// The pod's topology spread constraints.
				topologySpreadConstraints?: [...{
					labelSelector?: {
						matchExpressions?: [...{
							key?:      string
							operator?: string
							values?: [...string]
						}]
						matchLabels?: {
							[string]: string
						}
					}
					matchLabelKeys?: [...string]
					maxSkew?:            int
					minDomains?:         int
					nodeAffinityPolicy?: string
					nodeTaintsPolicy?:   string
					topologyKey?:        string
					whenUnsatisfiable?:  string
				}]
			}

			// Template for Kafka `PodDisruptionBudget`.
			podDisruptionBudget?: {
				// Maximum number of unavailable pods to allow automatic Pod
				// eviction. A Pod eviction is allowed when the `maxUnavailable`
				// number of pods or fewer are unavailable after the eviction.
				// Setting this value to 0 prevents all voluntary evictions, so
				// the pods must be evicted manually. Defaults to 1.
				maxUnavailable?: >=0 & int

				// Metadata to apply to the `PodDisruptionBudgetTemplate`
				// resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			podSet?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			serviceAccount?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for Kafka `StatefulSet`.
			statefulset?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}

				// PodManagementPolicy which will be used for this StatefulSet.
				// Valid values are `Parallel` and `OrderedReady`. Defaults to
				// `Parallel`.
				podManagementPolicy?: "OrderedReady" | "Parallel"
			}
		}

		// Configure the tiered storage feature for Kafka brokers.
		tieredStorage?: {
			// Configuration for the Remote Storage Manager.
			remoteStorageManager?: {
				// The class name for the `RemoteStorageManager` implementation.
				className?: string

				// The class path for the `RemoteStorageManager` implementation.
				classPath?: string

				// The additional configuration map for the `RemoteStorageManager`
				// implementation. Keys will be automatically prefixed with
				// `rsm.config.`, and added to Kafka broker configuration.
				config?: {
					[string]: string
				}
			}

			// Storage type, only 'custom' is supported at the moment.
			type: "custom"
		}

		// The Kafka broker version. Defaults to the latest version.
		// Consult the user documentation to understand the process
		// required to upgrade or downgrade the version.
		version?: string
	}

	// Configuration of the Kafka Exporter. Kafka Exporter can provide
	// additional metrics, for example lag of consumer group at
	// topic/partition.
	kafkaExporter?: {
		// Enable Sarama logging, a Go client library used by the Kafka
		// Exporter.
		enableSaramaLogging?: bool

		// Regular expression to specify which consumer groups to exclude.
		groupExcludeRegex?: string

		// Regular expression to specify which consumer groups to collect.
		// Default value is `.*`.
		groupRegex?: string

		// The container image used for the Kafka Exporter pods. If no
		// image name is explicitly specified, the image name corresponds
		// to the version specified in the Cluster Operator
		// configuration. If an image name is not defined in the Cluster
		// Operator configuration, a default value is used.
		image?: string

		// Pod liveness check.
		livenessProbe?: {
			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: >=1 & int

			// The initial delay before first the health is first checked.
			// Default to 15 seconds. Minimum value is 0.
			initialDelaySeconds?: >=0 & int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: >=1 & int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness. Minimum value is 1.
			successThreshold?: >=1 & int

			// The timeout for each attempted health check. Default to 5
			// seconds. Minimum value is 1.
			timeoutSeconds?: >=1 & int
		}

		// Only log messages with the given severity or above. Valid
		// levels: [`info`, `debug`, `trace`]. Default log level is
		// `info`.
		logging?: string

		// Pod readiness check.
		readinessProbe?: {
			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: >=1 & int

			// The initial delay before first the health is first checked.
			// Default to 15 seconds. Minimum value is 0.
			initialDelaySeconds?: >=0 & int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: >=1 & int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness. Minimum value is 1.
			successThreshold?: >=1 & int

			// The timeout for each attempted health check. Default to 5
			// seconds. Minimum value is 1.
			timeoutSeconds?: >=1 & int
		}

		// CPU and memory resources to reserve.
		resources?: {
			claims?: [...{
				name?: string
			}]
			limits?: {
				...
			}
			requests?: {
				...
			}
		}

		// Whether show the offset/lag for all consumer group, otherwise,
		// only show connected consumer groups.
		showAllOffsets?: bool

		// Customization of deployment templates and pods.
		template?: {
			// Template for the Kafka Exporter container.
			container?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}

			// Template for Kafka Exporter `Deployment`.
			deployment?: {
				// Pod replacement strategy for deployment configuration changes.
				// Valid values are `RollingUpdate` and `Recreate`. Defaults to
				// `RollingUpdate`.
				deploymentStrategy?: "RollingUpdate" | "Recreate"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for Kafka Exporter `Pods`.
			pod?: {
				// The pod's affinity rules.
				affinity?: {
					nodeAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							preference?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							nodeSelectorTerms?: [...{
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}]
						}
					}
					podAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
					podAntiAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
				}

				// Indicates whether information about services should be injected
				// into Pod's environment variables.
				enableServiceLinks?: bool

				// The pod's HostAliases. HostAliases is an optional list of hosts
				// and IPs that will be injected into the Pod's hosts file if
				// specified.
				hostAliases?: [...{
					hostnames?: [...string]
					ip?: string
				}]

				// List of references to secrets in the same namespace to use for
				// pulling any of the images used by this Pod. When the
				// `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster
				// Operator and the `imagePullSecrets` option are specified, only
				// the `imagePullSecrets` variable is used and the
				// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
				imagePullSecrets?: [...{
					name?: string
				}]

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}

				// The name of the priority class used to assign priority to the
				// pods.
				priorityClassName?: string

				// The name of the scheduler used to dispatch this `Pod`. If not
				// specified, the default scheduler will be used.
				schedulerName?: string

				// Configures pod-level security attributes and common container
				// settings.
				securityContext?: {
					fsGroup?:             int
					fsGroupChangePolicy?: string
					runAsGroup?:          int
					runAsNonRoot?:        bool
					runAsUser?:           int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					supplementalGroups?: [...int]
					sysctls?: [...{
						name?:  string
						value?: string
					}]
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}

				// The grace period is the duration in seconds after the processes
				// running in the pod are sent a termination signal, and the time
				// when the processes are forcibly halted with a kill signal. Set
				// this value to longer than the expected cleanup time for your
				// process. Value must be a non-negative integer. A zero value
				// indicates delete immediately. You might need to increase the
				// grace period for very large Kafka clusters, so that the Kafka
				// brokers have enough time to transfer their work to another
				// broker before they are terminated. Defaults to 30 seconds.
				terminationGracePeriodSeconds?: >=0 & int

				// Defines the total amount (for example `1Gi`) of local storage
				// required for temporary EmptyDir volume (`/tmp`). Default value
				// is `5Mi`.
				tmpDirSizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

				// The pod's tolerations.
				tolerations?: [...{
					effect?:            string
					key?:               string
					operator?:          string
					tolerationSeconds?: int
					value?:             string
				}]

				// The pod's topology spread constraints.
				topologySpreadConstraints?: [...{
					labelSelector?: {
						matchExpressions?: [...{
							key?:      string
							operator?: string
							values?: [...string]
						}]
						matchLabels?: {
							[string]: string
						}
					}
					matchLabelKeys?: [...string]
					maxSkew?:            int
					minDomains?:         int
					nodeAffinityPolicy?: string
					nodeTaintsPolicy?:   string
					topologyKey?:        string
					whenUnsatisfiable?:  string
				}]
			}
			service?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			serviceAccount?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
		}

		// Regular expression to specify which topics to exclude.
		topicExcludeRegex?: string

		// Regular expression to specify which topics to collect. Default
		// value is `.*`.
		topicRegex?: string
	}

	// A list of time windows for maintenance tasks (that is,
	// certificates renewal). Each time window is defined by a cron
	// expression.
	maintenanceTimeWindows?: [...string]

	// Configuration of the ZooKeeper cluster. This section is
	// required when running a ZooKeeper-based Apache Kafka cluster.
	zookeeper?: {
		// The ZooKeeper broker config. Properties with the following
		// prefixes cannot be set: server., dataDir, dataLogDir,
		// clientPort, authProvider, quorum.auth,
		// requireClientAuthScheme, snapshot.trust.empty,
		// standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist,
		// secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the
		// exception of: ssl.protocol, ssl.quorum.protocol,
		// ssl.enabledProtocols, ssl.quorum.enabledProtocols,
		// ssl.ciphersuites, ssl.quorum.ciphersuites,
		// ssl.hostnameVerification, ssl.quorum.hostnameVerification).
		config?: {
			...
		}

		// The container image used for ZooKeeper pods. If no image name
		// is explicitly specified, it is determined based on the Kafka
		// version set in `spec.kafka.version`. The image names are
		// specifically mapped to corresponding versions in the Cluster
		// Operator configuration.
		image?: string
		jmxOptions?: {
			authentication?: {
				// Authentication type. Currently the only supported types are
				// `password`.`password` type creates a username and protected
				// port with no TLS.
				type: "password"
			}
		}

		// JVM Options for pods.
		jvmOptions?: {
			// A map of -XX options to the JVM.
			"-XX"?: {
				[string]: string
			}

			// -Xms option to to the JVM.
			"-Xms"?: =~"^[0-9]+[mMgG]?$"

			// -Xmx option to to the JVM.
			"-Xmx"?: =~"^[0-9]+[mMgG]?$"

			// Specifies whether the Garbage Collection logging is enabled.
			// The default is false.
			gcLoggingEnabled?: bool

			// A map of additional system properties which will be passed
			// using the `-D` option to the JVM.
			javaSystemProperties?: [...{
				// The system property name.
				name?: string

				// The system property value.
				value?: string
			}]
		}

		// Pod liveness checking.
		livenessProbe?: {
			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: >=1 & int

			// The initial delay before first the health is first checked.
			// Default to 15 seconds. Minimum value is 0.
			initialDelaySeconds?: >=0 & int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: >=1 & int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness. Minimum value is 1.
			successThreshold?: >=1 & int

			// The timeout for each attempted health check. Default to 5
			// seconds. Minimum value is 1.
			timeoutSeconds?: >=1 & int
		}

		// Logging configuration for ZooKeeper.
		logging?: {
			// A Map from logger name to logger level.
			loggers?: {
				[string]: string
			}

			// Logging type, must be either 'inline' or 'external'.
			type: "inline" | "external"
			valueFrom?: {
				// Reference to the key in the ConfigMap containing the
				// configuration.
				configMapKeyRef?: {
					key?:      string
					name?:     string
					optional?: bool
				}
			}
		}

		// Metrics configuration.
		metricsConfig?: {
			// Metrics type. Only 'jmxPrometheusExporter' supported currently.
			type: "jmxPrometheusExporter"
			valueFrom: {
				// Reference to the key in the ConfigMap containing the
				// configuration.
				configMapKeyRef?: {
					key?:      string
					name?:     string
					optional?: bool
				}
			}
		}

		// Pod readiness checking.
		readinessProbe?: {
			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: >=1 & int

			// The initial delay before first the health is first checked.
			// Default to 15 seconds. Minimum value is 0.
			initialDelaySeconds?: >=0 & int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: >=1 & int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness. Minimum value is 1.
			successThreshold?: >=1 & int

			// The timeout for each attempted health check. Default to 5
			// seconds. Minimum value is 1.
			timeoutSeconds?: >=1 & int
		}

		// The number of pods in the cluster.
		replicas: >=1 & int

		// CPU and memory resources to reserve.
		resources?: {
			claims?: [...{
				name?: string
			}]
			limits?: {
				...
			}
			requests?: {
				...
			}
		}

		// Storage configuration (disk). Cannot be updated.
		storage: {
			// The storage class to use for dynamic volume allocation.
			class?: string

			// Specifies if the persistent volume claim has to be deleted when
			// the cluster is un-deployed.
			deleteClaim?: bool

			// Storage identification number. It is mandatory only for storage
			// volumes defined in a storage of type 'jbod'.
			id?: >=0 & int

			// Overrides for individual brokers. The `overrides` field allows
			// to specify a different configuration for different brokers.
			overrides?: [...{
				// Id of the kafka broker (broker identifier).
				broker?: int

				// The storage class to use for dynamic volume allocation for this
				// broker.
				class?: string
			}]

			// Specifies a specific persistent volume to use. It contains
			// key:value pairs representing labels for selecting such a
			// volume.
			selector?: {
				[string]: string
			}

			// When `type=persistent-claim`, defines the size of the
			// persistent volume claim, such as 100Gi. Mandatory when
			// `type=persistent-claim`.
			size?: string

			// When type=ephemeral, defines the total amount of local storage
			// required for this EmptyDir volume (for example 1Gi).
			sizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

			// Storage type, must be either 'ephemeral' or 'persistent-claim'.
			type: "ephemeral" | "persistent-claim"
		}

		// Template for ZooKeeper cluster resources. The template allows
		// users to specify how the Kubernetes resources are generated.
		template?: {
			// Template for ZooKeeper client `Service`.
			clientService?: {
				// Specifies the IP Families used by the service. Available
				// options are `IPv4` and `IPv6`. If unspecified, Kubernetes will
				// choose the default value based on the `ipFamilyPolicy`
				// setting.
				ipFamilies?: [..."IPv4" | "IPv6"]

				// Specifies the IP Family Policy used by the service. Available
				// options are `SingleStack`, `PreferDualStack` and
				// `RequireDualStack`. `SingleStack` is for a single IP family.
				// `PreferDualStack` is for two IP families on dual-stack
				// configured clusters or a single IP family on single-stack
				// clusters. `RequireDualStack` fails unless there are two IP
				// families on dual-stack configured clusters. If unspecified,
				// Kubernetes will choose the default value based on the service
				// type.
				ipFamilyPolicy?: "SingleStack" | "PreferDualStack" | "RequireDualStack"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			jmxSecret?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for ZooKeeper nodes `Service`.
			nodesService?: {
				// Specifies the IP Families used by the service. Available
				// options are `IPv4` and `IPv6`. If unspecified, Kubernetes will
				// choose the default value based on the `ipFamilyPolicy`
				// setting.
				ipFamilies?: [..."IPv4" | "IPv6"]

				// Specifies the IP Family Policy used by the service. Available
				// options are `SingleStack`, `PreferDualStack` and
				// `RequireDualStack`. `SingleStack` is for a single IP family.
				// `PreferDualStack` is for two IP families on dual-stack
				// configured clusters or a single IP family on single-stack
				// clusters. `RequireDualStack` fails unless there are two IP
				// families on dual-stack configured clusters. If unspecified,
				// Kubernetes will choose the default value based on the service
				// type.
				ipFamilyPolicy?: "SingleStack" | "PreferDualStack" | "RequireDualStack"

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			persistentVolumeClaim?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for ZooKeeper `Pods`.
			pod?: {
				// The pod's affinity rules.
				affinity?: {
					nodeAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							preference?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							nodeSelectorTerms?: [...{
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchFields?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
							}]
						}
					}
					podAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
					podAntiAffinity?: {
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							podAffinityTerm?: {
								labelSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								matchLabelKeys?: [...string]
								mismatchLabelKeys?: [...string]
								namespaceSelector?: {
									matchExpressions?: [...{
										key?:      string
										operator?: string
										values?: [...string]
									}]
									matchLabels?: {
										[string]: string
									}
								}
								namespaces?: [...string]
								topologyKey?: string
							}
							weight?: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							labelSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							matchLabelKeys?: [...string]
							mismatchLabelKeys?: [...string]
							namespaceSelector?: {
								matchExpressions?: [...{
									key?:      string
									operator?: string
									values?: [...string]
								}]
								matchLabels?: {
									[string]: string
								}
							}
							namespaces?: [...string]
							topologyKey?: string
						}]
					}
				}

				// Indicates whether information about services should be injected
				// into Pod's environment variables.
				enableServiceLinks?: bool

				// The pod's HostAliases. HostAliases is an optional list of hosts
				// and IPs that will be injected into the Pod's hosts file if
				// specified.
				hostAliases?: [...{
					hostnames?: [...string]
					ip?: string
				}]

				// List of references to secrets in the same namespace to use for
				// pulling any of the images used by this Pod. When the
				// `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster
				// Operator and the `imagePullSecrets` option are specified, only
				// the `imagePullSecrets` variable is used and the
				// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
				imagePullSecrets?: [...{
					name?: string
				}]

				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}

				// The name of the priority class used to assign priority to the
				// pods.
				priorityClassName?: string

				// The name of the scheduler used to dispatch this `Pod`. If not
				// specified, the default scheduler will be used.
				schedulerName?: string

				// Configures pod-level security attributes and common container
				// settings.
				securityContext?: {
					fsGroup?:             int
					fsGroupChangePolicy?: string
					runAsGroup?:          int
					runAsNonRoot?:        bool
					runAsUser?:           int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					supplementalGroups?: [...int]
					sysctls?: [...{
						name?:  string
						value?: string
					}]
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}

				// The grace period is the duration in seconds after the processes
				// running in the pod are sent a termination signal, and the time
				// when the processes are forcibly halted with a kill signal. Set
				// this value to longer than the expected cleanup time for your
				// process. Value must be a non-negative integer. A zero value
				// indicates delete immediately. You might need to increase the
				// grace period for very large Kafka clusters, so that the Kafka
				// brokers have enough time to transfer their work to another
				// broker before they are terminated. Defaults to 30 seconds.
				terminationGracePeriodSeconds?: >=0 & int

				// Defines the total amount (for example `1Gi`) of local storage
				// required for temporary EmptyDir volume (`/tmp`). Default value
				// is `5Mi`.
				tmpDirSizeLimit?: =~"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"

				// The pod's tolerations.
				tolerations?: [...{
					effect?:            string
					key?:               string
					operator?:          string
					tolerationSeconds?: int
					value?:             string
				}]

				// The pod's topology spread constraints.
				topologySpreadConstraints?: [...{
					labelSelector?: {
						matchExpressions?: [...{
							key?:      string
							operator?: string
							values?: [...string]
						}]
						matchLabels?: {
							[string]: string
						}
					}
					matchLabelKeys?: [...string]
					maxSkew?:            int
					minDomains?:         int
					nodeAffinityPolicy?: string
					nodeTaintsPolicy?:   string
					topologyKey?:        string
					whenUnsatisfiable?:  string
				}]
			}

			// Template for ZooKeeper `PodDisruptionBudget`.
			podDisruptionBudget?: {
				// Maximum number of unavailable pods to allow automatic Pod
				// eviction. A Pod eviction is allowed when the `maxUnavailable`
				// number of pods or fewer are unavailable after the eviction.
				// Setting this value to 0 prevents all voluntary evictions, so
				// the pods must be evicted manually. Defaults to 1.
				maxUnavailable?: >=0 & int

				// Metadata to apply to the `PodDisruptionBudgetTemplate`
				// resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			podSet?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}
			serviceAccount?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}
			}

			// Template for ZooKeeper `StatefulSet`.
			statefulset?: {
				// Metadata applied to the resource.
				metadata?: {
					// Annotations added to the Kubernetes resource.
					annotations?: {
						[string]: string
					}

					// Labels added to the Kubernetes resource.
					labels?: {
						[string]: string
					}
				}

				// PodManagementPolicy which will be used for this StatefulSet.
				// Valid values are `Parallel` and `OrderedReady`. Defaults to
				// `Parallel`.
				podManagementPolicy?: "OrderedReady" | "Parallel"
			}

			// Template for the ZooKeeper container.
			zookeeperContainer?: {
				// Environment variables which should be applied to the container.
				env?: [...{
					// The environment variable key.
					name?: string

					// The environment variable value.
					value?: string
				}]

				// Security context for the container.
				securityContext?: {
					allowPrivilegeEscalation?: bool
					capabilities?: {
						add?: [...string]
						drop?: [...string]
					}
					privileged?:             bool
					procMount?:              string
					readOnlyRootFilesystem?: bool
					runAsGroup?:             int
					runAsNonRoot?:           bool
					runAsUser?:              int
					seLinuxOptions?: {
						level?: string
						role?:  string
						type?:  string
						user?:  string
					}
					seccompProfile?: {
						localhostProfile?: string
						type?:             string
					}
					windowsOptions?: {
						gmsaCredentialSpec?:     string
						gmsaCredentialSpecName?: string
						hostProcess?:            bool
						runAsUserName?:          string
					}
				}
			}
		}
	}
}
